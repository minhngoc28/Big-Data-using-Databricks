
<!-- saved from url=(0012)about:srcdoc -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style>
    
/**
 * NB: this stylesheet is loaded inline in sandboxed HTML iframes that may contain
 * arbitrary untrusted content.  Be very careful what rules you add here.
 */
body, .mfe-root {
  background-color: transparent;
  margin: 0px;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 13px;
}

#content-wrapper {
  overflow: auto;
}

#content-wrapper .markdown {
  /**
   * without overriding this, the height is 100% (of the containing block), which is
   * initially quite small. The content will not fit, and will then depend on the
   * `overflow` property, which is `hidden`. In theory, `overflow: visible` will expand the
   * height to fit, but it has a bad interaction with postResizeMessage which causes the div
   * to keep growing in size under _some_ (ES-9273) circumstances. `height: auto` has the same
   * effect of allowing the browser to size the div but without the bad effects.
   **/
  height: auto;
}

/**
 * Approximates the JupyterLab Light theme for display of pandas-like DataFrames.
 *
 * TODO: JupyterLab parameterizes theme-able properties using CSS variables.  This
 * implementation hard-codes them.
 */
.dataframe {
  margin-left: 0;
  margin-right: 0;
  margin-bottom: 1em;
  border-collapse: collapse;
  border-spacing: 0;
  border: none;
  table-layout: fixed;
  user-select: text;
  -moz-user-select: text;
  -webkit-user-select: text;
  -ms-user-select: text;
}
.dataframe thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.dataframe tr {
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.dataframe th {
  font-size: 12px;
  font-weight: bold;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.dataframe tbody tr:nth-child(odd) {
  background: white;
}
.dataframe tbody tr:nth-child(even) {
  background: #f5f5f5;
}
.dataframe tbody tr:hover {
  background-color: rgb(218, 242, 254);
}
.dataframe tbody tr th:only-of-type {
  vertical-align: middle;
}
.dataframe tbody td {
  font-size: 12px;
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}

/**
 * CSS Variables to override the data summary (Data Profile) output
 */
#facets {
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif,'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'FontAwesome';
}

.db-summary-container .db-summary-items {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif,'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'FontAwesome';
}

  </style>
  <!--<base target="_blank">--><base href="." target="_blank">
  <script>
    (function() {
      var parentUri = 'https://databricks-prod-cloudfront.cloud.databricks.com';
      var originalWidth = null;
      var originalHeight = null;
      var scale = 1.0;
      window.onerror = function(error) {
        window.parent.postMessage({
          type: 'frameJsError',
          loc: window.location.href,
          frameId: 'iframe-guid-79fab971-2a82-4dfc-b65f-217cd64e9f17',
          error: error,
        }, parentUri);
      };
      function postResizeMessage() {
        // There are 3 cases, and we take the first that's available
        // 1) happy path: content is inlined. We use getBoundingClientRect to capture the dimension
        //    of (scaled) visible content, including the margin.
        //    {height, width} is captured via {bottom, right} to include any margin {top, left}.
        //    This will handle both when there's collapsing margin & not. See go/pr/43508
        // 2) content is loaded dynamically, in which case getBoundingClientRect().height may be 0.
        //    we use scroll{Width, Height} to capture the dimension regardless of what's currently
        //    visible.
        // 3) source in the iframe attaches to the document body and not the content-wrapper.
        //    we use document.body.scroll{Width, Height}. See ES-3770
        var wrapper = document.getElementById('content-wrapper');
        var rect = wrapper.getBoundingClientRect();
        var newWidth = (scale && rect.right / scale) || wrapper.scrollWidth || document.body.scrollWidth;
        var newHeight = (scale && rect.bottom / scale) || wrapper.scrollHeight || document.body.scrollHeight;
        if (Math.round(newWidth) != Math.round(originalWidth) || Math.round(newHeight) != Math.round(originalHeight)) {
          originalWidth = newWidth;
          originalHeight = newHeight;
          window.parent.postMessage({
            type: 'frameResizeEvent',
            frameId: 'iframe-guid-79fab971-2a82-4dfc-b65f-217cd64e9f17',
            loc: window.location.href,
            height: originalHeight,
            width: originalWidth,
            isAutoScaled: false,
          }, parentUri);
        }
      };
      // Sync size 4 times per second
      setInterval(postResizeMessage, 250);

      window.addEventListener('message', function(msg) {
        var origin = msg.origin || msg.originalEvent.origin;
        if (origin === 'null' && msg.data === '') {
          // Blank message from sandboxed iframe to itself; nothing to process.
          return;
        }
        var isExportedHTML = origin === 'null' && parentUri === '*';
        if (origin !== parentUri && !isExportedHTML) {
          console.error('Invalid origin', origin, parentUri);
          return;
        }

        
        // set wrapper div's height to be the height of the iframe to make vertical scrolling work
        var clientHeight = document.documentElement.clientHeight;
        document.body.style.height = clientHeight + 'px';
        
      });
      
    })();
  </script>
  </head><body style="height: 609px;"><div id="content-wrapper" class="">
    
        
        
            <script src="https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/7187073108757925/3842912221195175/7230453132478625/lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             

             
        </style>
    


    
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"><div class="vis-network" tabindex="0" style="position: relative; overflow: hidden; touch-action: pan-y; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;"><canvas width="2709" style="position: relative; touch-action: none; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;" height="907"></canvas></div></div>
        </div>

        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "ID1", "label": "ID1", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ID5", "label": "ID5", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ID3", "label": "ID3", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ID2", "label": "ID2", "shape": "dot", "size": 10}, {"color": "#97c2fc", "id": "ID4", "label": "ID4", "shape": "dot", "size": 10}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "ID1", "to": "ID5", "width": 1}, {"arrows": "to", "from": "ID1", "to": "ID3", "width": 1}, {"arrows": "to", "from": "ID5", "to": "ID2", "width": 1}, {"arrows": "to", "from": "ID5", "to": "ID3", "width": 1}, {"arrows": "to", "from": "ID3", "to": "ID2", "width": 1}, {"arrows": "to", "from": "ID2", "to": "ID1", "width": 1}, {"arrows": "to", "from": "ID2", "to": "ID5", "width": 1}, {"arrows": "to", "from": "ID2", "to": "ID3", "width": 1}, {"arrows": "to", "from": "ID2", "to": "ID4", "width": 1}, {"arrows": "to", "from": "ID4", "to": "ID3", "width": 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": false
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    

  </div></body></html>